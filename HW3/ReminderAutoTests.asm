#Я решил задачу исходя из того что можно было использовать только сложение и вычитание,
#а также ветвления и цкилы. Однако если можно было бы использовать функцию смены знака,
#то размер программы можно некисло сократить.
#
#Тесты реализованы для всех случаев, но для случае с делением на 0 я не смог придумать как 
#это корректно проверять, поэтому его придется просто просмотреть :)
.data
prompt_dividend: .asciz "Enter the dividend: "       # Строка запроса делимого
prompt_divisor: .asciz "Enter the divisor:  "        # Строка запроса делителя
error_divide_by_zero: .asciz "Error: division by zero."  # Сообщение об ошибке деления на ноль
result_quotient: .asciz "Quotient: "                  # Строка для вывода частного
result_remainder: .asciz " Remainder: "                # Строка для вывода остатка
newline: .asciz "\n"                                   # Строка для новой строки
test_passed: .asciz "Test passed\n"                   # Сообщение о прохождении теста
test_failed: .asciz "Test failed\n"                   # Сообщение о неудачном тесте

test_cases: 
    .word 15, 4, 3, 3                                  # Тестовые данные: делимое, делитель, ожидаемое частное, ожидаемый остаток
    .word 10, 3, 3, 1  
    .word 9, 2, 4, 1    
    .word 8, 5, 1, 3    
    .word 14, 3, 4, 2   
    .word 20, 6, 3, 2   
    .word -15, 4, -3, -3 
    .word 15, -4, -3, 3 
    .word -10, -3, 3, -1 
    .word 0, 5, 0, 0   
    .word 5, 5, 1, 0   
    .word 7, 3, 2, 1    
    .word 18, 7, 2, 4  
    .word -18, 7, -2, -4  
    .word 18, -7, -2, 4 
    .word 21, 0, 0, 0    # Тест с делителем 0, у него  нет проверки в формате test passed(не смог реализовать)

.text
main:
    la      t3, test_cases          # Загрузка адреса массива тестовых случаев
    li      t4, 15                   # Установка счетчика тестов (количество тестов)

test_loop:
    lw      t0, 0(t3)               # Загрузка делимого из массива
    lw      t1, 4(t3)               # Загрузка делителя из массива
    lw      t5, 8(t3)               # Загрузка ожидаемого частного из массива
    lw      t6, 12(t3)              # Загрузка ожидаемого остатка из массива

    # Проверка деления на ноль
    beqz    t1, divide_by_zero       # Если делитель равен 0, перейти к обработке ошибки

    # Логика деления
    li      t2, 0                    # Инициализация частного в 0
    bltz    t0, dividend_less_zero    # Если делимое отрицательное, перейти к соответствующему циклу
    bgtz    t1, division_loop_both_greater_zero  # Если делимое положительное и делитель положительный, перейти к соответствующему циклу
    j       division_loop_divisor_less_zero       # Если делимое положительное и делитель отрицательный, перейти к соответствующему циклу
    dividend_less_zero:
   	 bgtz    t1, division_loop_dividend_less_zero  # Если  делимое отрицательное и делитель положительный, перейти к соответствующему циклу
    	 j       division_loop_both_less_zero           # Если оба отрицательные, перейти к соответствующему циклу

division_loop_both_greater_zero:
    blt     t0, t1, division_done                  # Если делимое меньше делителя, перейти к завершению деления
    sub     t0, t0, t1                             # Вычитание делителя из делимого
    addi    t2, t2, 1                               # Увеличение частного на 1
    j       division_loop_both_greater_zero       # Повторить цикл

division_loop_both_less_zero:
    bgt     t0, t1, division_done                  # Если делимое больше делителя, перейти к завершению
    sub     t0, t0, t1                             # Вычитание делителя из делимого
    addi    t2, t2, 1                               # Увеличение частного на 1
    j       division_loop_both_less_zero          # Повторить цикл

division_loop_dividend_less_zero:
    bgtz    t0, step_back                          # Если делимое положительное, перейти к возврату
    add     t0, t0, t1                             # Добавление делителя к делимому
    addi    t2, t2, -1                             # Уменьшение частного на 1
    j       division_loop_dividend_less_zero      # Повторить цикл

division_loop_divisor_less_zero:
    bltz    t0, step_back                          # Если делимое отрицательное, перейти к возврату
    add     t0, t0, t1                             # Добавление делителя к делимому
    addi    t2, t2, -1                             # Уменьшение частного на 1
    j       division_loop_divisor_less_zero       # Повторить цикл

step_back:
    sub     t0, t0, t1                             # Вычитание делителя из делимого
    addi    t2, t2, 1                               # Увеличение частного на 1
    j       division_done                          # Переход к завершению деления

division_done:
    # Вывод результата
    li      a7, 4                                  # Код для печати строки
    la      a0, result_quotient                    # Адрес строки "Частное"
    ecall                                           # Вызов системного вызова для печати строки
    mv      a0, t2                                 # Перемещение частного в a0 для печати
    li      a7, 1                                  # Код для печати целого числа
    ecall                                           # Вызов системного вызова для печати числа

    li      a7, 4                                  # Код для печати строки
    la      a0, result_remainder                    # Адрес строки "Остаток"
    ecall                                           # Вызов системного вызова для печати строки
    mv      a0, t0                                 # Перемещение остатка в a0 для печати
    li      a7, 1                                  # Код для печати целого числа
    ecall                                           # Вызов системного вызова для печати числа

    # Проверка результата
    beq     t2, t5, check_remainder               # Если частное совпадает, перейти к проверке остатка
    j       test_failed_message                     # В противном случае, сообщение о неудаче

check_remainder:
    beq     t0, t6, test_passed_message            # Если остаток совпадает, тест пройден
    j       test_failed_message                     # В противном случае, сообщение о неудаче

test_passed_message:
    li      a7, 4                                  # Код для печати строки
    la      a0, newline                             # Адрес строки новой строки
    ecall                                           # Вызов системного вызова для печати строки
    la      a0, test_passed                        # Адрес строки "Тест пройден"
    ecall                                           # Вызов системного вызова для печати строки
    j       test_end                               # Переход к завершению теста

test_failed_message:
    li      a7, 4                                  # Код для печати строки
    la      a0, newline                             # Адрес строки новой строки
    ecall                                           # Вызов системного вызова для печати строки
    la      a0, test_failed                        # Адрес строки "Тест не пройден"
    ecall                                           # Вызов системного вызова для печати строки

test_end:
    # Печать новой строки
    li      a7, 4                                  # Код для печати строки
    la      a0, newline                             # Адрес строки новой строки
    ecall                                           # Вызов системного вызова для печати строки

    # Переход к следующему тесту
    addi    t3, t3, 16                             # Переход к следующей паре (делимое, делитель, частное, остаток)
    addi    t4, t4, -1                              # Уменьшение счетчика тестов
    bgez    t4, test_loop                           # Если тесты не закончены, повторить

    j       exit                                    # Завершение программы

divide_by_zero:
    li      a7, 4                                  # Код для печати строки
    la      a0, error_divide_by_zero               # Адрес строки "Ошибка"
    ecall                                           # Вызов системного вызова для печати строки
    # Печать новой строки
    li      a7, 4                                  # Код для печати строки
    la      a0, newline                             # Адрес строки новой строки
    ecall                                           # Вызов системного вызова для печати строки
    j       exit                                    # Завершение программы

exit:
    li      a7, 10                                 # Код для завершения программы
    ecall                                           # Вызов системного вызова для завершения
